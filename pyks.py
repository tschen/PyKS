#############################################################################
##
## Copyright (c) 2017 Tim Chen
##
## This file is part of PyKS.
##
## This file may be used under the terms of the GNU General Public License
## version 3.0 as published by the Free Software Foundation and appearing in
## the file LICENSE included in the packaging of this file.  Please review the
## following information to ensure the GNU General Public License version 3.0
## requirements will be met: http://www.gnu.org/copyleft/gpl.html.
##
## This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
## WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
## See the GNU Public License along with PyKS.
##
#############################################################################
# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtNetwork, QtSql, QtWidgets

# Python3 std lib imports
import collections
import hashlib
import json
import os
import re
import sys
import time

# PyKS imports
from cdg import CdgPlayer
from server import KaraokeServer
from ui_clientswindow import Ui_ClientsWindow
from ui_lyricswindow import Ui_LyricsWindow
from ui_mainwindow import Ui_MainWindow
from ui_queuewindow import Ui_QueueWindow
from widgets import AboutDialog, AddToPlaylistDialog, AlertDialog, \
    ClientsModel, SonglistModel, DragDropSqlQueryModel, Settings, \
    SettingsDialog


class LyricsWindow(QtWidgets.QMainWindow, Ui_LyricsWindow):
    closedWindow = QtCore.pyqtSignal()

    def __init__(self, cdgPlayer, parent=None):
        super(LyricsWindow, self).__init__(parent)
        self.setupUi(self)
        # WA_OpaquePaintEvent indicates that the widget paints all its pixels
        # when it receives a paint event, so it's not necessary to erase the
        # widget before generating paint events.
        self.setAttribute(QtCore.Qt.WA_OpaquePaintEvent)
        self.cdgPlayer = cdgPlayer
        self.cdgImage = cdgPlayer.getCdgImage()
        self.cdgPlayer.cdgImageUpdated.connect(self.update)


    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.drawImage(event.rect(), self.cdgImage)


    def mouseDoubleClickEvent(self, event):
        # If double click were generated by a left click, toggle the size of
        # the window
        if event.button() == QtCore.Qt.LeftButton:
            if self.isFullScreen():
                self.showNormal()
                # Set the cursor to be visible
                self.setCursor(QtCore.Qt.ArrowCursor)
            else:
                self.showFullScreen()
                # Set the cursor to be invisible
                self.setCursor(QtCore.Qt.BlankCursor)


    def keyPressEvent(self, event):
        # If Esc is pressed in full sreen mode, return to normal mode
        if (event.key() == QtCore.Qt.Key_Escape and self.isFullScreen()):
            self.showNormal()
            # Set the cursor to be visible
            self.setCursor(QtCore.Qt.ArrowCursor)


    # Signal when the window is closed
    def closeEvent(self, event):
        self.closedWindow.emit()


class QueueWindow(QtWidgets.QMainWindow, Ui_QueueWindow):
    closedWindow = QtCore.pyqtSignal()
    songsSelected = QtCore.pyqtSignal(list)
    dropAction = QtCore.pyqtSignal(dict)

    def __init__(self, parent=None):
        super(QueueWindow, self).__init__(parent)
        self.setupUi(self)
        self.queueModel = SonglistModel(self)
        self.queueTableView.setModel(self.queueModel)
        self.queueTableView.verticalHeader().setVisible(False)
        # Hide the song ID column
        self.queueTableView.hideColumn(SonglistModel.SONG_ID_COL)
        # Hide the IP Addresses column
        self.queueTableView.hideColumn(SonglistModel.IP_ADDRESS_COL)
        # Remove songs when "del" key is pressed
        self.queueTableView.removeSongs.connect(self.removeFromQueue)
        # Use a custom context menu
        self.queueTableView.customContextMenuRequested.connect(
            self.showQueueContextMenu)

        # Signals and slots
        self.queueTableView.activated.connect(self.activated)
        self.queueModel.dropAction.connect(self.dropAction.emit)


    def appendSongs(self, songs):
        self.queueModel.appendSongs(songs)
        for col in range(self.queueModel.NUM_COLS - 1):
            self.queueTableView.resizeColumnToContents(col)
        self.queueTableView.horizontalHeader().setStretchLastSection(True)


    def insertInQueueAt(self, songs, index):
        self.queueModel.insertSongs(index, songs)
        for col in range(self.queueModel.NUM_COLS - 1):
            self.queueTableView.resizeColumnToContents(col)
        self.queueTableView.horizontalHeader().setStretchLastSection(True)


    @QtCore.pyqtSlot()
    def removeFromQueue(self):
        rows = self.queueTableView.selectionModel().selectedRows()

        # We remove songs in ascending order because with each song removed
        # the index of the next song to remove decrements by 1
        rows.sort()
        self.queueModel.removeSongs(
            [modelIndex.row() for modelIndex in rows])


    @QtCore.pyqtSlot(QtCore.QPoint)
    def showQueueContextMenu(self, position):
        menu = QtWidgets.QMenu(self)
        removeFromQueueAction = QtWidgets.QAction\
            ("Remove from queue", self)
        removeFromQueueAction.triggered.connect(self.removeFromQueue)
        menu.addAction(removeFromQueueAction)
        # Place menu where the cursor is
        menu.exec(self.queueTableView.mapToGlobal(position))


    @QtCore.pyqtSlot()
    def activated(self):
        selectedSongs = []
        songPositions = []

        rows = self.queueTableView.selectionModel().selectedRows()
        for modelIndex in rows:
            performer = self.queueModel.index(modelIndex.row(),
                                               SonglistModel.PERF_COL).data()
            songName = self.queueModel.index(modelIndex.row(),
                                             SonglistModel.SONG_NAME_COL).data()
            songID = self.queueModel.index(modelIndex.row(),
                                           SonglistModel.SONG_ID_COL).data()
            ipAddress = self.queueModel.index(modelIndex.row(), 
                                              SonglistModel.
                                              IP_ADDRESS_COL).data()
            selectedSongs.append([performer, songName, songID, ipAddress])

            songPositions.append(modelIndex.row())

        self.queueModel.removeSongs(songPositions)
        self.songsSelected.emit(selectedSongs)


    # On a close, if there are songs in the queue, check if the user wants to
    # move the songs to the playlist.
    def closeEvent(self, event):
        # There are still songs in the queue
        if self.queueModel.rowCount() > 0:

            confirmClose = QtWidgets.QMessageBox(self)
            confirmClose.setWindowTitle("Confirm Close")
            confirmClose.setText("There are still songs in the song queue.\n"
                                 "Do you want to move them to the playlist?")
            confirmClose.setStandardButtons(QtWidgets.QMessageBox.Yes |
                                            QtWidgets.QMessageBox.No |
                                            QtWidgets.QMessageBox.Cancel)
            confirmClose.setDefaultButton(QtWidgets.QMessageBox.Yes)
            font = QtGui.QFont()
            font.setPointSize(11)
            font.setBold(False)
            font.setWeight(50)
            confirmClose.setFont(font)
            result = confirmClose.exec()
            if result == QtWidgets.QMessageBox.Cancel:
                event.ignore()
            else:
                if result == QtWidgets.QMessageBox.Yes:
                    self.songsSelected.emit(self.queueModel.getSonglist())
                self.closedWindow.emit()
        self.closedWindow.emit()


class ClientsWindow(QtWidgets.QMainWindow, Ui_ClientsWindow):
    closedWindow = QtCore.pyqtSignal()
    removedClients = QtCore.pyqtSignal(list)
    updatedNumClients = QtCore.pyqtSignal(int)

    def __init__(self, parent=None):
        super(ClientsWindow, self).__init__(parent)
        self.setupUi(self)
        
        # Set up QSortFilterProxyModel to allow for sorting
        self.clientsModel = ClientsModel(self)
        self.sortFilterProxyModel = QtCore.QSortFilterProxyModel(self)
        self.sortFilterProxyModel.setSourceModel(self.clientsModel)
        self.clientsTableView.setModel(self.sortFilterProxyModel)
        self.clientsTableView.verticalHeader().setVisible(False)
        # Remove client when "del" key is pressed
        self.clientsTableView.removeSongs.connect(self.removeSelectedClients)
        # Use a custom context menu
        self.clientsTableView.customContextMenuRequested.connect(
            self.showClientsContextMenu)


    @QtCore.pyqtSlot(str)
    def addClient(self, clientAddress):
        self.clientsModel.addClient(clientAddress)
        for col in range(self.clientsModel.NUM_COLS - 1):
            self.clientsTableView.resizeColumnToContents(col)
        self.clientsTableView.horizontalHeader().setStretchLastSection(True)
        self.updatedNumClients.emit(self.clientsModel.getNumClients())


    @QtCore.pyqtSlot(str)
    def removeClient(self, clientAddress):
        self.clientsModel.removeClient(clientAddress)
        self.updatedNumClients.emit(self.clientsModel.getNumClients())


    @QtCore.pyqtSlot()
    def removeSelectedClients(self):
        rows = self.clientsTableView.selectionModel().selectedRows()
        
        # Remove clients from the server
        clientAddresses = []
        for modelIndex in rows:
            address = self.clientsModel.index(modelIndex.row(),
                                              ClientsModel.
                                              CLIENT_ADDRESS_COL).data()
            clientAddresses.append(address)
        # We don't actually remove clients here. We just send a signal to the
        # server to remove them. The server will emit a signal to us when they
        # are removed.
        self.removedClients.emit(clientAddresses)
  
  
    @QtCore.pyqtSlot(str)
    def updateClientAdminStatus(self, clientAddress):
        self.clientsModel.updateClientAdminStatus(clientAddress)
  
  
    @QtCore.pyqtSlot(QtCore.QPoint)
    def showClientsContextMenu(self, position):
        menu = QtWidgets.QMenu(self)
        removeFromClientsAction = QtWidgets.QAction\
            ("Remove client(s)", self)
        removeFromClientsAction.triggered.connect(
            self.removeSelectedClients)
        menu.addAction(removeFromClientsAction)
        # Place menu where the cursor is
        menu.exec(self.clientsTableView.mapToGlobal(position))


    @QtCore.pyqtSlot(int)
    def getNumClients(self):
        return self.clientsModel.getNumClients()

    
    def closeEvent(self, event):
        self.closedWindow.emit()


class PyKS(QtWidgets.QMainWindow, Ui_MainWindow):
    VERSION = 1.0

    SETTINGS_FILE = 'pyks.ini'
    SONGBOOK_DB_FILE = 'songbook.db'
    SONGBOOK_JSON_FILE = 'songbook.json'

    songbookUpdated = QtCore.pyqtSignal('QString')

    def __init__(self, parent=None):
        super(PyKS, self).__init__(parent)

        # Run Ui_MainWindow.setupUi() to set up the main window
        self.setupUi(self)

        # Get the user's home directory
        pyksHome = os.path.expanduser('~')

        # If expanduser failed (i.e. '~' remains unchanged), use the current
        # directory.
        if pyksHome == '~':
            pyksHome = './';
        else:
            pyksHome = os.path.join(pyksHome, '.pyks')
            # If the .pyks directory does not exist, try to create it
            if not os.path.exists(pyksHome):
                try:
                    os.mkdir(pyksHome, 0o755)
                except: # On exception use current directory
                    pyksHome = './'

        self.settingsFile = os.path.join(pyksHome, self.SETTINGS_FILE)
        self.songbookdbFile = os.path.join(pyksHome, self.SONGBOOK_DB_FILE)
        self.songbookJSONFile = os.path.join(pyksHome, self.SONGBOOK_JSON_FILE)

        # On startup, import settings from pyks.ini if the file exists.
        # If the file does not exist, create it with default settings.
        if os.path.isfile(self.settingsFile):
            self.settings = Settings.readSettings(self.settingsFile)
        else:
            # Create default settings
            self.settings = Settings()
            # Write settings to ini file
            Settings.writeSettings(self.settings, self.settingsFile)

        # The songbook is stored as a SQLite database and as a JSON file on
        # disk. The SQLLite database is used by the main app while the JSON
        # file is used by the web app. On startup try to open both files.
        # If the database does not exist, create it by searching
        # through files found in self.settings.searchFolders.
        self.songbookdb = QtSql.QSqlDatabase.addDatabase('QSQLITE')
        self.songbookdb.setDatabaseName(self.songbookdbFile)
        # We close the database when the app closes
        self.songbookdb.open()

        if not os.path.isfile(self.songbookdbFile) or not os.path.isfile(
                self.songbookJSONFile):
            self._createSongbook(self.settings.searchFolders)

        # Open the JSON file and read in its contents
        self.songbookJSON = open (self.songbookJSONFile, 'r').read()

        # Setup search results panel
        # The underlying model holding the data displayed by
        # searchResultsListView is a DragDropSqlModel (which
        # inherits from QSqlQueryModel) contained in a
        # QSortFilterProxyModel to allow for sorting.
        self.sqlQueryModel = DragDropSqlQueryModel(self)
        self.sqlQueryModel.setQuery\
            ('SELECT artist, title, songID from songs')

        # QSqlQueryModel only fetches 256 rows at a time
        # Keep fetching until all rows are fetched
        while (self.sqlQueryModel.canFetchMore()):

            # This may take several iterations. Process events so we don't
            # block the main UI.
            QtCore.QCoreApplication.processEvents()

            self.sqlQueryModel.fetchMore()

        # Set up QSortFilterProxyModel to allow for sorting
        self.sortFilterProxyModel = QtCore.QSortFilterProxyModel(self)
        self.sortFilterProxyModel.setSourceModel(self.sqlQueryModel)
        self.sortFilterProxyModel.setHeaderData(
            DragDropSqlQueryModel.ARTIST_COL, QtCore.Qt.Horizontal, 'Artist')
        self.sortFilterProxyModel.setHeaderData(
            DragDropSqlQueryModel.TITLE_COL, QtCore.Qt.Horizontal, 'Title')

        # Set the searchResultsTableView to use srtFilterProxyModel as its
        # underlying data container
        self.searchResultsTableView.setModel(self.sortFilterProxyModel)
        # Hide the first column of row numbers
        self.searchResultsTableView.verticalHeader().setVisible(False)
        # First sort by title and then by artist. This ensures that titles from
        # the same artist are sorted alphabetically.
        self.searchResultsTableView.sortByColumn(
            DragDropSqlQueryModel.TITLE_COL, QtCore.Qt.AscendingOrder)
        self.searchResultsTableView.sortByColumn(
            DragDropSqlQueryModel.ARTIST_COL, QtCore.Qt.AscendingOrder)
        # Hide Song ID column
        self.searchResultsTableView.hideColumn(
            DragDropSqlQueryModel.SONG_ID_COL)
        # Set QTableView selection behavior to select only rows
        self.searchResultsTableView.setSelectionBehavior(
            QtWidgets.QAbstractItemView.SelectRows)
        self._resizeAllColumnsExceptLast(self.searchResultsTableView, 
                                         DragDropSqlQueryModel.NUM_COLS)
        # searchResultsTableView Signal/Slot
        self.searchResultsTableView.activated.connect(self.addToPlaylist)
        self.searchResultsTableView.customContextMenuRequested.connect(
            self.showSearchResultsContextMenu)

        # Setup the searchLineEdit to perform searches as the user types.
        # The keypressTimer is a singleshot timer used to delay executing
        # search queries until the user has stopped typing for specified period
        # of time. This prevents us from flooding the database with search
        # queries.
        self.__keypressTimer = QtCore.QTimer()
        self.__keypressTimer.setSingleShot(True)
        self.__keypressTimer.timeout.connect(self.processSearch)
        self.searchLineEdit.textChanged.connect (self.startKeypressTimer)

        # Setup the playlist panel
        # The playlist is a list of tuples where each tuple contains the
        # following:
        # (performer's name, song name, song ID)
        # The playlist data structure is contained in a SonglistModel and is
        # manipulated through calls to the model's methods.
        self.playlistModel = SonglistModel(self)
        self.playlistTableView.setModel(self.playlistModel)
        self.playlistTableView.verticalHeader().setVisible(False)
        # Hide the song ID column
        self.playlistTableView.hideColumn(SonglistModel.SONG_ID_COL)
        # Hide the IP addresses column
        self.playlistTableView.hideColumn(SonglistModel.IP_ADDRESS_COL)
        # If we are not in performer mode, hide the performer column and the
        # "Show Song Queue" toolbar button
        if not self.settings.performerMode:
            self.playlistTableView.hideColumn(SonglistModel.PERF_COL)
            self.actionShowQueueWindow.setVisible(False)

        # Remove songs when "del" key is pressed
        self.playlistTableView.removeSongs.connect(self.removeFromPlaylist)
        # Use a custom context menu
        self.playlistTableView.customContextMenuRequested.connect(
            self.showPlaylistContextMenu)

        # Set up the song queue if in performerMode queueOnStartup is True
        self.queue = None
        if self.settings.performerMode and self.settings.queueOnStartup:
            self.showQueue()

        # Setup buttons
        self.playButton.clicked.connect(self.play)
        self.stopButton.clicked.connect(self.stop)
        self.nextButton.clicked.connect(self.next)

        # Setup toolbar and menu
        self.actionMenuNewScreen.triggered.connect(self.showNewLyricsWindow)
        self.actionNewScreen.triggered.connect(self.showNewLyricsWindow)
        self.actionMenuSettings.triggered.connect(self.showSettings)
        self.actionMenuAbout.triggered.connect(self.showAbout)
        self.actionShowQueueWindow.triggered.connect(self.showQueue)
        self.actionToggleServer.triggered.connect(self.toggleServer)

        # CdgPlayer
        self.cdgPlayer = CdgPlayer()
        # Play next song (if there is one) when we reach the end of the
        # current song
        self.cdgPlayer.endOfMedia.connect(self.processEndOfMedia)

        # Set up the clients window
        self.clientsWindow = ClientsWindow()
        self.clientsWindow.closedWindow.connect(self.closeClientsWindow)
        self.clientsWindow.updatedNumClients.connect(self.updateNumClients)

        # KaraokeServer
        self.karaokeServer = KaraokeServer (self.songbookJSON)
        self.karaokeServerState = KaraokeServer.OFF
        # Set up a QPushButton on the toolbar. We will replace the text of the 
        # button whenever we toggle the server's state.
        # NOTE: This needs ot be setup before we try to start the server
        self.serverInfoButton = QtWidgets.QPushButton()
        self.toolBar.addWidget(self.serverInfoButton)
        self.serverInfoButton.clicked.connect(self.showClientsWindow)
        self.serverOnIcon = QtGui.QIcon()
        self.serverOnIcon.addPixmap(QtGui.QPixmap(":/images/start_server.png"),
                                     QtGui.QIcon.Normal,
                                     QtGui.QIcon.Off)
        self.serverOffIcon = QtGui.QIcon()
        self.serverOffIcon.addPixmap(QtGui.QPixmap(":/images/stop_server.png"),
                                    QtGui.QIcon.Normal,
                                    QtGui.QIcon.Off)
        # We need to connect the serverStateChanged signal before trying to
        # start the server.
        self.karaokeServer.serverStateChanged.connect(
            self.processServerStateChanged)

        if self.settings.serverOnStartup:
            result = self.karaokeServer.startServer(
                QtNetwork.QHostAddress(self.settings.hostAddress),
                self.settings.hostPort, self.settings.maxConnectedClients,
                self.settings.allowMultipleConnections,
                self.settings.adminPassword)
            if not result:
                alert = AlertDialog("Karaoke Server Error",
                                    "Could not start Karaoke Server on %s:%d" %
                                    (self.settings.hostAddress,
                                    self.settings.hostPort))
                alert.exec()
                # If we fail to connect on startup, set the server toggle
                # icon to serverOffIcon
                self.processServerStateChanged(KaraokeServer.OFF)
        else: # Set the server toggle icon to serverOffIcon
            self.processServerStateChanged(KaraokeServer.OFF)

        self.karaokeServer.addToPlaylist.connect(self.appendToSonglist)
        self.karaokeServer.play.connect(self.play)
        self.karaokeServer.nextSong.connect(self.next)
        self.karaokeServer.stop.connect(self.stop)
        self.karaokeServer.playNow.connect(self.insertInPlaylistAt)
        self.karaokeServer.playNext.connect(self.insertInPlaylistAt)
        
        self.karaokeServer.clientConnected.connect(self.clientsWindow.addClient)
        self.karaokeServer.clientDisconnected.connect(
            self.clientsWindow.removeClient)        
        self.clientsWindow.removedClients.connect(
            self.karaokeServer.removeClients)
        self.karaokeServer.updatedClientAdminStatus.connect(
            self.clientsWindow.updateClientAdminStatus)

        self.songbookUpdated.connect(self.karaokeServer.updateSongbook)
        self.playlistModel.songlistUpdated.connect(
            self.karaokeServer.updatePlaylist)
        self.playlistModel.dropAction.connect(
            self.doPlaylistDropAction)


        # Holds all references to open lyrics windows. Since lysics windows
        # don't have parents, this list keeps them from closing by saving their
        # reference
        self.lyricsWindows = []


    ###### Slots
    @QtCore.pyqtSlot()
    def play(self):
        song = self.playlistModel.getCurSong()
        self._playSong(song)


    @QtCore.pyqtSlot()
    def next(self):
        nextSong = self.playlistModel.getNextSong()
        self._playSong(nextSong)


    def _playSong (self, song):
        self.stop()
        if song:
            songName = song[SonglistModel.SONG_NAME]
            songID = song[SonglistModel.SONG_ID]
            # Get mp3 filepath and cdg filepath from the database
            query = QtSql.QSqlQuery()
            query.exec('SELECT mp3FilePath, cdgFilePath from songs where '
                       'songID = %d' % songID)
            # retrieve the result and play the song
            if query.first():
                isPlaying = self.cdgPlayer.play(query.value(0), query.value(1))
            else:
                alert = AlertDialog("Song Not Found",
                                    'Could not play "%s"' %
                                    songName)
                alert.exec()
                # Remove the song from the list
                self.playlistModel.removeSongs([0])
                return

            if isPlaying:
                # If there are no lyrics windows being displayed, open one
                if len(self.lyricsWindows) < 1:
                    self.showNewLyricsWindow()


    @QtCore.pyqtSlot()
    def stop(self):
        self.cdgPlayer.stop()


    @QtCore.pyqtSlot()
    def processEndOfMedia(self):
        # if secondsToWait = -1, don't go to the next song. Otherwise,
        # set a timer to wait settings.secondsToWait seconds before playing the
        # next song.
        if self.settings.secondsToWait >= 0:
            timer = QtCore.QTimer(self)
            timer.timeout.connect(self.next)
            timer.setSingleShot(True)
            # Convert seconds to milliseconds
            timer.start(self.settings.secondsToWait * 1000)


    @QtCore.pyqtSlot()
    def playNow(self):
        result = self._insertSongAt(0)
        if result:
            self.stop()
            self.play()


    @QtCore.pyqtSlot()
    def playNext(self):
        self._insertSongAt(1)


    @QtCore.pyqtSlot(dict)
    def doQueueDropAction(self, dragDropData):
        performer = ""

        (result, performer) = self._confirmAddToPlaylist(
            dragDropData['songs'])

        if result:
            selectedSongs = [[performer] + selectedSong + ['localhost'] 
                             for selectedSong in dragDropData['songs']]
            if dragDropData['indexes'] == -1:
                self.appendToSonglist(selectedSongs)
            else:
                self.queue.insertInQueueAt(selectedSongs, dragDropData[
                    'indexes'])


    @QtCore.pyqtSlot(dict)
    def doPlaylistDropAction(self, dragDropData):
        performer = ""

        # If we are in performer mode, prompt the user for ther performer's
        # name before adding the songs to the playlist
        if self.settings.performerMode:
            (result, performer) = self._confirmAddToPlaylist(
                dragDropData['songs'])

        if not self.settings.performerMode or result:
            selectedSongs = [[performer] + selectedSong + ['localhost'] 
                            for selectedSong in dragDropData['songs']]
            if dragDropData['indexes'] == -1:
                self.appendToPlaylist(selectedSongs)
            else:
                self.insertInPlaylistAt(selectedSongs, dragDropData['indexes'])


    @QtCore.pyqtSlot()
    def addToPlaylist(self):
        selectedSongs = []
        performer = ""

        rows = self.searchResultsTableView.selectionModel().selectedRows()
        for modelIndex in rows:
            songName = (self.sortFilterProxyModel.index(
                modelIndex.row(), DragDropSqlQueryModel.ARTIST_COL).data()
                        + ' - '
                        + self.sortFilterProxyModel.index(
                modelIndex.row(), DragDropSqlQueryModel.TITLE_COL).data())
            songID = self.sortFilterProxyModel.index(
                modelIndex.row(), DragDropSqlQueryModel.SONG_ID_COL).data()
            selectedSongs.append([songName, songID])

        # If we are in performer mode, prompt the user for ther performer's
        # name before adding the songs to the playlist
        if self.settings.performerMode:
            (result, performer) = self._confirmAddToPlaylist(selectedSongs)

        if not self.settings.performerMode or result:
            selectedSongs = [[performer] + selectedSong 
                             + ['localhost'] for selectedSong in selectedSongs]
            self.appendToSonglist(selectedSongs)


    @QtCore.pyqtSlot(list)
    def appendToSonglist(self, songs):
        if self.settings.performerMode and self.queue:
            self.queue.appendSongs(songs)
        else:
            self.appendToPlaylist(songs)


    @QtCore.pyqtSlot(list)
    def appendToPlaylist(self, songs):
        self.playlistModel.appendSongs(songs)
        self._resizeAllColumnsExceptLast(self.playlistTableView, 
                                         SonglistModel.NUM_COLS)


    @QtCore.pyqtSlot(list, int)
    def insertInPlaylistAt(self, song, position):
        self.playlistModel.insertSongs(position, song)
        self._resizeAllColumnsExceptLast(self.playlistTableView, 
                                         SonglistModel.NUM_COLS)


    def _insertSongAt(self, position):
        performer = ""
        songInfo = self._getSearchResultsSelection()
        if songInfo:
            songName = songInfo[DragDropSqlQueryModel.ARTIST_COL] \
                       + ' - ' \
                       + songInfo[DragDropSqlQueryModel.TITLE_COL]
            songID = songInfo[DragDropSqlQueryModel.SONG_ID_COL]
            selectedSong = [[songName, songID]]
            if self.settings.performerMode:
                (result, performer) = self._confirmAddToPlaylist(selectedSong)

            if not self.settings.performerMode or result:
                selectedSong = [[performer] + selectedSong[0] + ['localhost']]
                self.insertInPlaylistAt(selectedSong, position)
                return True
        return False


    def _getSearchResultsSelection(self):
        modelIndex = self.searchResultsTableView.selectionModel().currentIndex()
        if modelIndex:
            return (self.sortFilterProxyModel.index
                    (modelIndex.row(), DragDropSqlQueryModel.ARTIST_COL).data(),
                    self.sortFilterProxyModel.index
                    (modelIndex.row(), DragDropSqlQueryModel.TITLE_COL).data(),
                    self.sortFilterProxyModel.index
                    (modelIndex.row(), 
                     DragDropSqlQueryModel.SONG_ID_COL).data())
        else:
            return None


    def _confirmAddToPlaylist(self, selectedSongs):
        performer = ""
        addToPlaylistDialog = \
            AddToPlaylistDialog([selectedSong[0] for selectedSong in
                                 selectedSongs],
                                self.settings.defaultPerformerName,
                                self.settings.alwaysUsePerformersName,
                                self)
        result = addToPlaylistDialog.exec()
        if result:
            performer = addToPlaylistDialog.performerNameLineEdit.text()
            self.settings.alwaysUsePerformersName = \
                addToPlaylistDialog.alwaysUseNameCheckbox.isChecked()
            if self.settings.alwaysUsePerformersName:
                self.settings.defaultPerformerName = \
                    addToPlaylistDialog.performerNameLineEdit.text()
            else:
                self.settings.defaultPerformerName = ""
        return (result, performer)


    @QtCore.pyqtSlot()
    def processSearch(self):
        # Grab search text and query the database for results
        text = self.searchLineEdit.text().strip()

        query = QtSql.QSqlQuery()
        query.prepare(
            'SELECT artist, title, songID FROM songs '
            'WHERE LOWER(artistNoPunc) LIKE LOWER(?) '
            'OR LOWER(artist) like LOWER (?)'
            'OR LOWER(titleNoPunc) like LOWER (?)'
            'OR LOWER(title) like LOWER (?) '
            'ORDER BY artist, title COLLATE NOCASE')
        query.addBindValue('%' + text + '%')
        query.addBindValue('%' + text + '%')
        query.addBindValue('%' + text + '%')
        query.addBindValue('%' + text + '%')
        query.exec_()
        self.sqlQueryModel.setQuery(query)

        # QSqlQueryModel only fetches 256 rows at a time
        # Keep fetching until all rows are fetched
        while (self.sqlQueryModel.canFetchMore()):

            # This may take several iterations. Process events so we don't
            # block the main UI.
            QtCore.QCoreApplication.processEvents()

            self.sqlQueryModel.fetchMore()


    @QtCore.pyqtSlot()
    def startKeypressTimer(self):
        # Stop the timer
        # If it is still active, this means that the user has not finished
        # typing
        self.__keypressTimer.stop()
        # Start the timer for 250 ms
        self.__keypressTimer.start(250)


    @QtCore.pyqtSlot()
    def showNewLyricsWindow(self):
        lyricsWindow = LyricsWindow(self.cdgPlayer)
        lyricsWindow.closedWindow.connect(self.closeLyricsWindow)
        lyricsWindow.show()
        self.lyricsWindows.append(lyricsWindow)


    @QtCore.pyqtSlot()
    def closeLyricsWindow(self):
        lyricsWindow = self.sender()
        self.lyricsWindows.remove(lyricsWindow)
        # if there are no more lyrics windows, then stop playback
        if len(self.lyricsWindows) < 1:
            self.stop()


    @QtCore.pyqtSlot()
    def toggleServer(self):
        if self.karaokeServerState == KaraokeServer.ON:
            self.karaokeServer.stopServer()
        else:
            result = self.karaokeServer.startServer(
                QtNetwork.QHostAddress(self.settings.hostAddress),
                self.settings.hostPort, self.settings.maxConnectedClients,
                self.settings.allowMultipleConnections,
                self.settings.adminPassword)
            if not result:
                alert = AlertDialog("Karaoke Server Error", "Could not start "
                                                            "Karaoke Server "
                                                            "on %s:%d" %
                                    (self.settings.hostAddress,
                                     self.settings.hostPort))
                alert.exec()


    @QtCore.pyqtSlot(int)
    def processServerStateChanged(self, state):
        self.karaokeServerState = state
        if state == KaraokeServer.ON:
            self.actionToggleServer.setIcon(self.serverOffIcon)
            self.updateNumClients(
                self.clientsWindow.getNumClients())
            self.actionToggleServer.setToolTip("Turn server off")
        else:
            self.actionToggleServer.setIcon(self.serverOnIcon)
            self.serverInfoButton.setText("Not Serving")
            self.actionToggleServer.setToolTip("Turn server on")


    @QtCore.pyqtSlot(int)
    def updateNumClients(self, int):
        self.serverInfoButton.setText("Serving %d clients: %s:%d" % (
            self.clientsWindow.getNumClients(),
            self.settings.hostAddress,
            self.settings.hostPort))


    @QtCore.pyqtSlot()
    def showSettings(self):
        settingsDialog = SettingsDialog(self.settings, self)
        settingsDialog.updateDatabaseClicked.connect(self.updateDatabaseClicked)
        settingsDialog.exec()
        if settingsDialog.result():
            self._processNewSettings(settingsDialog.getSettings())


    @QtCore.pyqtSlot()
    def showAbout(self):
        aboutDialog = AboutDialog(self.VERSION, self)
        aboutDialog.exec()


    @QtCore.pyqtSlot(list)
    def updateDatabaseClicked(self, searchFolders):
        # On update database click, update our searchFolders setting with the
        # new folders and write out the settings to the ini file
        self._createSongbook(searchFolders)
        self.sqlQueryModel.setQuery \
            ('SELECT artist, title, songID from songs')
        # QSqlQueryModel only fetches 256 rows at a time
        # Keep fetching until all rows are fetched
        while (self.sqlQueryModel.canFetchMore()):

            # This may take several iterations. Process events so we don't
            # block the main UI.
            QtCore.QCoreApplication.processEvents()

            self.sqlQueryModel.fetchMore()
        # Hide Song ID column
        self.searchResultsTableView.hideColumn(
            DragDropSqlQueryModel.SONG_ID_COL)
        self._resizeAllColumnsExceptLast(self.searchResultsTableView, 
                                         DragDropSqlQueryModel.NUM_COLS)
        self.settings.searchFolders = searchFolders
        Settings.writeSettings(self.settings, self.settingsFile)
        self.karaokeServer.updateSongbook(self.songbookJSON)


    def _processNewSettings (self, newSettings):
        if newSettings.performerMode != self.settings.performerMode:
            # Toggle to performer mode
            if newSettings.performerMode:
                self.playlistTableView.showColumn(SonglistModel.PERF_COL)
                self.actionShowQueueWindow.setVisible(True)
            else: # Toggle back to non performer mode
                self.playlistTableView.hideColumn(SonglistModel.PERF_COL)
                # If there is a queue, close it gracefully
                if self.queue:
                    self.queue.close()
                    self.actionShowQueueWindow.setVisible(False)

        if set(newSettings.searchFolders) != set (self.settings.searchFolders):
            self._createSongbook(newSettings.searchFolders)
            self.sqlQueryModel.setQuery \
                ('SELECT artist, title, songID from songs')
            # QSqlQueryModel only fetches 256 rows at a time
            # Keep fetching until all rows are fetched
            while (self.sqlQueryModel.canFetchMore()):

                # This may take several iterations. Process events so we don't
                # block the main UI.
                QtCore.QCoreApplication.processEvents()

                self.sqlQueryModel.fetchMore()
            # Hide Song ID column
            self.searchResultsTableView.hideColumn(
                DragDropSqlQueryModel.SONG_ID_COL)

            # Need to set up table again for new content
            self._resizeAllColumnsExceptLast(self.searchResultsTableView, 
                                             DragDropSqlQueryModel.NUM_COLS)
            self.sortFilterProxyModel.setHeaderData(
                DragDropSqlQueryModel.ARTIST_COL,
                QtCore.Qt.Horizontal,
                'Artist')
            self.sortFilterProxyModel.setHeaderData(
                DragDropSqlQueryModel.TITLE_COL, QtCore.Qt.Horizontal, 'Title')

        # If any server settings change and the server is serving, alert the
        # user that they need to reset the server for the new settings to be
        # used.
        if (self.karaokeServerState == KaraokeServer.ON
            and (newSettings.hostAddress != self.settings.hostAddress
                 or newSettings.hostPort != self.settings.hostPort
                 or newSettings.adminPassword != self.settings.adminPassword
                 or newSettings.allowMultipleConnections !=
                    self.settings.allowMultipleConnections
                 or newSettings.maxConnectedClients !=
                    self.settings.maxConnectedClients)):
            alert = AlertDialog("New Server Settings Detected",
                                "Toggle the server off and on "
                                "to use the new settings")
            alert.exec()


        self.settings = newSettings
        # Write out new settings
        Settings.writeSettings(self.settings, self.settingsFile)


    @QtCore.pyqtSlot(QtCore.QPoint)
    def showSearchResultsContextMenu(self, position):
        menu = QtWidgets.QMenu(self)
        playNowAct = QtWidgets.QAction("Play now", self)
        playNowAct.triggered.connect(self.playNow)
        menu.addAction(playNowAct)

        playNextAct = QtWidgets.QAction("Play next", self)
        playNextAct.triggered.connect(self.playNext)
        menu.addAction(playNextAct)

        separatorAct = QtWidgets.QAction(self)
        separatorAct.setSeparator(True)
        menu.addAction(separatorAct);

        addToPlaylistAct = QtWidgets.QAction("Add to playlist", self)
        addToPlaylistAct.triggered.connect(self.addToPlaylist)
        menu.addAction(addToPlaylistAct)

        # Place menu where the cursor is
        menu.exec(self.searchResultsTableView.mapToGlobal(position))


    @QtCore.pyqtSlot(QtCore.QPoint)
    def showPlaylistContextMenu(self, position):
        menu = QtWidgets.QMenu(self)
        removeFromPlaylistAction = QtWidgets.QAction\
            ("Remove from playlist", self)
        removeFromPlaylistAction.triggered.connect(self.removeFromPlaylist)
        menu.addAction(removeFromPlaylistAction)
        # Place menu where the cursor is
        menu.exec(self.playlistTableView.mapToGlobal(position))


    @QtCore.pyqtSlot()
    def removeFromPlaylist(self):
        rows = self.playlistTableView.selectionModel().selectedRows()
        numRemoved = 0

        # We remove songs in ascending order because with each song removed
        # the index of the next song to remove decrements by 1
        rows.sort()
        self.playlistModel.removeSongs(
            [modelIndex.row() for modelIndex in rows])


    def showQueue(self):
        if not self.queue:
            self.queue = QueueWindow()
            self.queue.songsSelected.connect(self.appendToPlaylist)
            self.queue.dropAction.connect(self.doQueueDropAction)
            self.queue.closedWindow.connect(self.closeQueueWindow)
        self.queue.showNormal()
        self.queue.raise_()
    
    
    @QtCore.pyqtSlot()
    def closeQueueWindow(self):
        self.queue = None
    
    
    @QtCore.pyqtSlot()
    def showClientsWindow(self):
        self.clientsWindow.show()
        
        # Make IP Addresses columns in the playlist and queue (if queue is
        # visible) visible
        self.playlistTableView.showColumn(SonglistModel.IP_ADDRESS_COL)
        if self.queue:
            self.queue.queueTableView.showColumn(SonglistModel.IP_ADDRESS_COL)
        
    
    @QtCore.pyqtSlot()
    def closeClientsWindow(self):
        # Hide the IP addresses column on a clientsWindow close
        self.playlistTableView.hideColumn(SonglistModel.IP_ADDRESS_COL)
        self._resizeAllColumnsExceptLast(self.playlistTableView, 
                                         SonglistModel.NUM_COLS)
        if self.queue:
            self.queue.queueTableView.hideColumn(SonglistModel.IP_ADDRESS_COL)
            self._resizeAllColumnsExceptLast(self.queue.queueTableView,
                                             SonglistModel.NUM_COLS)
    
    
    def _createSongbook (self, searchFolders):
        # Convert to a set to remove any redundant folders
        searchFolders = set(searchFolders)

        self.songbookdb.exec('DROP TABLE songs')
        self.songbookdb.exec(
                'CREATE TABLE songs(artist TEXT, artistNoPunc TEXT, '
                'title TEXT, titleNoPunc TEXT, '
                'mp3FilePath TEXT, cdgFilePath TEXT, '
                'songID INTEGER PRIMARY KEY AUTOINCREMENT)')

        # Create the songbook JSON file
        # The file will have the following structure:
        # {"response": "getsongbook""data": [{"artist": artist, "title": title,
        # "artistNoPunc":
        #            artistNoPunc, "titleNoPunc": titleNoPunc, "songID": id},...
        #           ]}
        self.songbookJSON = []
        f = open(self.songbookJSONFile, 'w')

        # We scan through the folders and store mp3 files we find in the
        # mp3Files dictionary as
        # {mp3_lowercase_filepath_no_ext : mp3_filepath} and
        # cdg files we find in the cdgFiles dictionary as
        # {cdg_lowercase_filepath_no_ext : cdg_filepath}.
        # We then go through each mp3 file entry in mp3Files and check to see
        # if it is in cdgFiles. If it is, we insert that pair in our
        # songbook database. If there is no match for the mp3 file, we store
        # its file path in unmatchedSongs which will be written to a log
        # file in the end. After all mp3_files are checked, we check cdgFiles
        # for any cdgFiles which were never matched and write those files to
        # unmatchedSongs.
        # Note, we use the whole filepath as the key because that uniquely
        # identifies a song.
        mp3Files = {}
        cdgFiles = {}
        unmatchedSongs = []


        for searchFolder in searchFolders:
            for path, dirs, filenames in os.walk(searchFolder):
                for file in filenames:
                    # Get filename and extension
                    name, ext = os.path.splitext(file)

                    # Get filepath in lower case without extension to use as a
                    # key. We use the lower case filepath as the key because
                    # in Windows, filenames are case insensitive.
                    # Therefore we can have cases where "foo.mp3" should match
                    # with "FOO.cdg.
                    lowerCaseFilepath = (path.replace ('\\','/') + '/'
                                           + name).lower()
                    filepath = path.replace('\\', '/') + '/' + file

                    if ext.lower() == '.mp3':
                        mp3Files[lowerCaseFilepath] = filepath
                    elif ext.lower() == '.cdg':
                        cdgFiles[lowerCaseFilepath] = filepath

        # Count total mp3 and cdg files found. If there are files to process
        # (i.e. totalFiles > 0), display a QProgressDialog and process the
        # the files.
        totalFiles = len(mp3Files) + len(cdgFiles)
        if totalFiles > 0:
            progressDialog = QtWidgets.QProgressDialog(self,
                                                       QtCore.Qt.WindowTitleHint
                                                       | QtCore.Qt.
                                                       WindowCloseButtonHint)
            progressDialog.setWindowTitle("Loading Songs")
            # Only show the progressDialog if 2000ms has passed
            progressDialog.setMinimumDuration(2000)
            progressDialog.setWindowModality(QtCore.Qt.WindowModal)
            progressDialog.setCancelButton(None)
            progressDialog.setRange(0, totalFiles)

            # Start a database transaction. We only want to commit the
            # database inserts as a batch rather than one at a time.
            self.songbookdb.transaction()
            i = 0
            while i < (totalFiles):
                # If there are mp3_files, process them first.
                if len(mp3Files):
                    fileKey, mp3FilePath = mp3Files.popitem()
                    # Check if filename exists in cdg_files. If it does,
                    # add the song to the database.
                    cdgFilePath = cdgFiles.get(fileKey)
                    if cdgFilePath:
                        # We arbitrarily use the mp3FilePath filename as the
                        # text we parse for "artist" and "title" entries. We
                        # don't use file_key because it was converted into
                        # lower case.
                        artistTitle = os.path.splitext(os.path.basename (
                            os.path.normpath(mp3FilePath)))[0]
                        self._addSongToDB(artistTitle, mp3FilePath,
                                         cdgFilePath)

                        # Remove the cdg file from cdg_files and increment "i"
                        # 2 to update the progress bar.
                        del cdgFiles[fileKey]
                        i += 2
                    else: # Could not find a cdg match for the mp3 file
                        unmatchedSongs.append(mp3FilePath)
                        i += 1
                elif len (cdgFiles): # Process leftover cdg files
                    fileKey, cdgFilePath = cdgFiles.popitem()
                    unmatchedSongs.append(cdgFilePath)
                    i += 1

                progressDialog.setValue(i)
                progressDialog.setLabelText\
                    ("Processing file number %d of %d" % (i, totalFiles))
                progressDialog.setMinimumWidth(300)
                QtCore.QCoreApplication.processEvents()

            # Delete the progressDialog
            progressDialog.deleteLater()

            # Once all song insertions have been executed, commit the
            # transactions
            self.songbookdb.commit()

            # Calculate the MD5 hash of the songbook. This will be used by
            # the web app client to verify whether it needs to re-download the
            # songbook if it reconnects.
            m = hashlib.md5()
            m.update(bytes(json.dumps(self.songbookJSON), 'utf-8'))

            self.songbookJSON = {"cmd": "getSongbook",
                                 "response": {"md5": m.hexdigest(),
                                              "songbook":
                                                  {"data": self.songbookJSON}}}
            self.songbookJSON = json.dumps(self.songbookJSON)
            f.write(self.songbookJSON)

            # If there are unmatched songs, write them out to a log file so
            # the user can fix them.
            if unmatchedSongs:
                timestamp = time.strftime('%Y%m%d_%H%M%S')
                # Try to create a logs directory if one does not exist
                if not os.path.isdir('logs'):
                    os.makedirs('logs')
                try:
                    f = open(
                        'logs/unmatched_song_files_' + timestamp + '.log',
                        'w')
                    unmatchedSongs.sort()
                    for song in unmatchedSongs:
                        f.write ('%s\n' % song)
                    f.close()
                except:
                    return
            self.songbookUpdated.emit(self.songbookJSON)
        f.close()


    def _addSongToDB (self, artistTitle, mp3FilePath, cdgFilePath):
        (artist, artistNoPunc, title, titleNoPunc) = \
            self._parseSongName(artistTitle)

        query = QtSql.QSqlQuery()
        query.prepare(
            'INSERT INTO songs (artist, artistNoPunc, '
            'title, titleNoPunc, mp3FilePath, cdgFilePath)'
            ' VALUES (?, ?, ?, ?, ?, ?)')
        query.addBindValue(artist)
        query.addBindValue(artistNoPunc)
        query.addBindValue(title)
        query.addBindValue(titleNoPunc)
        query.addBindValue(mp3FilePath)
        query.addBindValue(cdgFilePath)
        query.exec_()

        query.exec('SELECT max(songID) FROM songs')
        query.first()
        lastRowID = query.value(0)

        # Add the song to songbookJSON
        self.songbookJSON.append(collections.OrderedDict(
            {"artist": artist,
             "title": title,
             "artistNoPunc": artistNoPunc,
             "titleNoPunc": titleNoPunc,
             "songID": lastRowID}))


    def _parseSongName(self, artistTitle):
        # Separate artist and title from the filename. We assume a hyphen
        # separates the two.
        splitPattern = "(.+)\s+-\s+(.+)"
        m = re.match(splitPattern, artistTitle)
        if m:  # If there is a match
            artist = m.group(1)
            title = m.group(2)
        else:
            artist = "Unknown"
            title = artistTitle

        # Create "no punctuation" versions of artistTitle
        puncPattern = "['|`|,|.|(|)|-]"
        artistNoPunc = re.sub(puncPattern, "", artist)
        titleNoPunc = re.sub(puncPattern, "", title)

        return (artist, artistNoPunc, title, titleNoPunc)


    def _resizeAllColumnsExceptLast(self, tableView, num_cols):
        for col in range(num_cols - 1):
            tableView.resizeColumnToContents(col)
        tableView.horizontalHeader().setStretchLastSection(True)


    def closeEvent(self, event):
        # If there are still songs in the playlist, confirm that the user
        # wants to close the program
        if self.playlistModel.rowCount() > 0:
            confirmClose = QtWidgets.QMessageBox(self)
            confirmClose.setWindowTitle("Confirm Close")
            confirmClose.setText("Really close PyKS?")
            confirmClose.setStandardButtons(QtWidgets.QMessageBox.Yes |
                                            QtWidgets.QMessageBox.No)
            confirmClose.setDefaultButton(QtWidgets.QMessageBox.No)
            font = QtGui.QFont()
            font.setPointSize(11)
            font.setBold(False)
            font.setWeight(50)
            confirmClose.setFont(font)
            result = confirmClose.exec()

            if result == QtWidgets.QMessageBox.Yes:
                self._cleanup()
            else:
                event.ignore()
        else:
            self._cleanup()


    def _cleanup(self):
        # Close the database
        self.songbookdb.close()

        # Close all lyricsWindows
        for lyricsWindow in self.lyricsWindows:
            lyricsWindow.deleteLater()

        # Close the queue
        if self.queue:
            self.queue.deleteLater()
        
        self.clientsWindow.deleteLater()


def main():
    app = QtWidgets.QApplication(sys.argv)
    pyks = PyKS()
    pyks.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
